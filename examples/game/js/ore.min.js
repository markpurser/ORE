/**
 * @license
 * ore.min.js - v0.0.1
 *
 * Licensed under the MIT License.
 * http://github.com/markpurser/ORE/LICENSE
*/

/*
* ORE - Online Roguelike Engine
*
* Copyright (C) 2016  Mark Purser
* Released under the MIT license
* http://github.com/markpurser/ORE/LICENSE
*/

/**
* @module Buffer
*
* Implements a multi-directional cyclic look-ahead buffer
*/

this.ORE = this.ORE || {};

(function () {
    function Buffer(viewPos, pageWidth, pageHeight)
    {
        this._pageWidth = pageWidth;
        this._pageHeight = pageHeight;

        this._geoCache = {geoCode:null, page:null};

        this.initialise(viewPos);

        console.log("Hello from Buffer constructor");
    }

    var p = Buffer.prototype;

    Buffer._bufferWidth = 6;
    Buffer._numPages = Buffer._bufferWidth * Buffer._bufferWidth;

    p.initialise = function(viewPos)
    {
        // makes the buffer into a grid graph of pages
        this.makeGridGraph();

        // identify all pages with a geo code
        this.fillGeoCodes(viewPos);

        // fill page data with random cells
        this.fillBufferTestData();

        console.log("Hello from Buffer::initialise");
    };

    p.fastTileCode = function(pos, sprites, tileTextures)
    {
        var geoCode = this.geoCode(pos);
        var leftPage = this.findPage(geoCode);
        var page = leftPage;

        if(page)
        {
            var edge = { x: this._pageWidth, y: this._pageHeight };
            var offset = { x: pos.x - geoCode.x, y: pos.y - geoCode.y };

            var y = offset.y;

            for(var i = 0; i < edge.y; i++)
            {
                var x = offset.x;

                for(var j = 0; j < edge.x; j++)
                {
                    tileCode = page.data[x + y * this._pageWidth];
                    sprites[j + i * this._pageWidth].texture = tileTextures[tileCode];

                    x++;
                    if( x == edge.x )
                    {
                        x = 0;
                        page = page.r;
                    }
                }

                y++;
                if( y == edge.y )
                {
                    y = 0;
                    leftPage = leftPage.d;
                }

                page = leftPage;
            }
        }
    };

    p.findPage = function(geoCode)
    {
        var width = Buffer._bufferWidth;
        var page = this._buffer[0];

        for(var i = 0; i < width; i++)
        {
            for(var j = 0; j < width; j++)
            {
                if(_.isEqual(page.geoCode, geoCode))
                {
                    return page;
                }
                page = page.r;
            }
            page = page.d;
        }

        return null;
    };

    p.fillBufferTestData = function()
    {
        var width = Buffer._bufferWidth;
        var page = this._buffer[0];
        var cellValue = 0;

        for(var i = 0; i < width; i++)
        {
            for(var j = 0; j < width; j++)
            {
                this.fillPageTestData(page, cellValue);
                page = page.r;
                cellValue++;
            }
            page = page.d;
        }
    };

    p.fillPageTestData = function(page, cellValue)
    {
        for(var x = 0; x < this._pageWidth; x++)
        {
            for(var y = 0; y < this._pageHeight; y++)
            {
                page.data[x + y * this._pageWidth] = cellValue;
            }
        }
    };

    // Fill pages with geo codes
    p.fillGeoCodes = function(viewPos)
    {
        var tempPos = {x: viewPos.x - this._pageWidth*2, y: viewPos.y - this._pageHeight*2};
        var startx = tempPos.x;

        var width = Buffer._bufferWidth;
        var page = this._buffer[0];

        for(var i = 0; i < width; i++)
        {
            for(var j = 0; j < width; j++)
            {
                page.geoCode = this.geoCode(tempPos);

                console.log(page.geoCode);

                tempPos.x += this._pageWidth;
                page = page.r;
            }

            tempPos.x = startx;
            tempPos.y += this._pageHeight;
            page = page.d;
        }
    };

    p.geoCode = function(pos)
    {
        return {
            x: pos.x - ( pos.x % this._pageWidth ),
            y: pos.y - ( pos.y % this._pageHeight )
        };
    };

    // Create an undirected grid graph consisting of page nodes
    p.makeGridGraph = function()
    {
        var pagesQ = new Queue();
        this._buffer = [];

        for(var i = 0; i < Buffer._numPages; i++)
        {
            var page = { id: 'page-'+i, data: [], stale: true, l: null, r: null, u: null, d: null };
            this._buffer.push(page);
            pagesQ.enqueue(page);
        }

        this.linkAdjacencyProperties(pagesQ);
    };

    // Link the left, right, up and down (l,r,u,d) adjacency list of each page
    p.linkAdjacencyProperties = function(pagesQ)
    {
        var rowQ = new Queue();
        var width = Buffer._bufferWidth;

        // push the first row
        for(var i = 0; i < width; i++)
        {
            var p = pagesQ.dequeue();
            rowQ.enqueue(p);
            // rotate the first row back on to the end of the pagesQ so
            // that the final row gets linked to the first row
            pagesQ.enqueue(p);
        }

        // iterate rows
        for(i = 0; i < width; i++)
        {
            var nextRowQ = new Queue();

            // add the first page in the row to the end
            // this ensures that the final page in the row gets linked to the first
            rowQ.enqueue(rowQ.peek());

            // iterate columns
            for(var j = 0; j < width; j++)
            {
                var page = rowQ.dequeue();
                var nextRowPage = pagesQ.dequeue();

                page.r = rowQ.peek();
                page.r.l = page;
                page.d = nextRowPage;
                page.d.u = page;

                nextRowQ.enqueue(nextRowPage);
            }

            rowQ = nextRowQ;
        }
    };

    ORE.Buffer = Buffer;

}());

/*
* ORE - Online Roguelike Engine
*
* Copyright (C) 2016  Mark Purser
* Released under the MIT license
* http://github.com/markpurser/ORE/LICENSE
*
* Tile rendering based on
* https://github.com/jice-nospam/yendor.ts
* Copyright (c) 2014 Jice
*/

/**
* @module ORE
*/

this.ORE = this.ORE || {};

(function () {
    ORE.init = function (oreOptions)
    {
        this._renderingCanvas = oreOptions.canvas;

        this._keyboard = new Keyboard();

        var tileWidthPx = oreOptions.tileWidthPx;
        var tileHeightPx = oreOptions.tileHeightPx;

        var mapViewWidth = oreOptions.mapViewWidth;
        var mapViewHeight = oreOptions.mapViewHeight;

        var viewPos = { x:2060, y:2070 };
        this._buffer = new ORE.Buffer(viewPos, mapViewWidth, mapViewHeight);

        var loader = PIXI.loader;
        loader.add('tilesheet', oreOptions.tilesheetImage);
        loader.load( function( loader, resources )
        {
            var stats = {
                fpsText: new PIXI.Text('', {font: '24px Arial', fill: 0xff1010}),
                fpsTimer: 0,
                currentFrameCount: 0
            };

            var numTilesX = resources.tilesheet.texture.width / tileWidthPx;
            var numTilesY = resources.tilesheet.texture.height / tileHeightPx;

            var bufferWidth = mapViewWidth * 6;
            var bufferHeight = mapViewHeight * 6;

            // create a new instance of a pixi container
            var gameViewContainer = new PIXI.Container();
            var parentContainer = new PIXI.Container();

            parentContainer.addChild(gameViewContainer);
            parentContainer.addChild(stats.fpsText);

            var playerX = viewPos.x * tileWidthPx;
            var playerY = viewPos.y * tileHeightPx;

            // create a renderer instance
            var pixiOptions = {
                clearBeforeRender: true,
                preserveDrawingBuffer: false,
                resolution: 1,
                view: ORE._renderingCanvas
            };

            ORE._renderer = PIXI.autoDetectRenderer(0, 0, pixiOptions);
            ORE._renderer.backgroundColor = 0x66ff99;

            // add the renderer view element to the DOM
            //document.body.appendChild(ORE._renderer.view);


            // init tile textures
            var tileTextures = [];
            _.range(numTilesX).forEach(function(x)
            {
                _.range(numTilesY).forEach(function(y)
                {
                    var rect = new PIXI.Rectangle(x * tileWidthPx, y * tileHeightPx, tileWidthPx, tileHeightPx);
                    tileTextures[x + y * numTilesX] = new PIXI.Texture(resources.tilesheet.texture, rect);
                });
            });

            // init tile buffer
            var buffer = [];
            _.range(bufferWidth).forEach(function(x)
            {
                _.range(bufferHeight).forEach(function(y)
                {
                    buffer[x + y * bufferWidth] = _.random(63);
                });
            });

            // init game sprites
            var sprites = [];    
            _.range(mapViewWidth).forEach(function(x)
            {
                _.range(mapViewHeight).forEach(function(y)
                {
                    var sprite = new PIXI.Sprite(tileTextures[0]);
                    sprite.position.x = x * tileWidthPx;
                    sprite.position.y = y * tileHeightPx;
                    sprite.width = tileWidthPx;
                    sprite.height = tileHeightPx;
                    sprites[x + y * mapViewWidth] = sprite;
                    gameViewContainer.addChild(sprite);
                });
            });

            requestAnimationFrame(animate);

            function animate()
            {
                if(oreOptions.displayStats)
                {
                    ORE.updateStats(stats);
                }

                if(ORE._keyboard.isKeyPressed(Keyboard.KEYS.UP))
                {
                    playerY--;
                }

                if(ORE._keyboard.isKeyPressed(Keyboard.KEYS.DOWN))
                {
                    playerY++;
                }

                if(ORE._keyboard.isKeyPressed(Keyboard.KEYS.LEFT))
                {
                    playerX--;
                }

                if(ORE._keyboard.isKeyPressed(Keyboard.KEYS.RIGHT))
                {
                    playerX++;
                }

                viewPos.x = playerX >> 4;
                viewPos.y = playerY >> 4;
                var scrollX = playerX & 15;
                var scrollY = playerY & 15;
                gameViewContainer.position.x = -scrollX;
                gameViewContainer.position.y = -scrollY;

                ORE._buffer.fastTileCode(viewPos, sprites, tileTextures);

                requestAnimationFrame(animate);

                // render
                ORE._renderer.render(parentContainer);
            }
        });
    };

    ORE.updateStats = function (stats)
    {
        stats.currentFrameCount++;
        if( stats.fpsTimer === 0 )
        {
            stats.fpsTimer = new Date().getTime();
        }
        else if( new Date().getTime() - stats.fpsTimer > 1000 )
        {
            var rendererTypeStr = 'Canvas';
            if(ORE._renderer instanceof PIXI.WebGLRenderer)
            {
                rendererTypeStr = 'WebGL';
            }
            stats.fpsText.text = 'fps: ' + stats.currentFrameCount + '\npixi: ' + PIXI.VERSION + '\nRenderer: ' + rendererTypeStr;
            stats.fpsTimer = new Date().getTime();
            stats.currentFrameCount = 0;
        }
    };

})();
