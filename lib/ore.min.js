/**
 * @license
 * ore.min.js - v0.0.1
 *
 * Licensed under the MIT License.
 * http://github.com/markpurser/ORE/LICENSE
*/

/*
* ORE - Online Roguelike Engine
*
* Copyright (C) 2016  Mark Purser
* Released under the MIT license
* http://github.com/markpurser/ORE/LICENSE
*/

/**
* @module Buffer
*
* Implements a multi-directional cyclic look-ahead buffer
*/

this.ORE = this.ORE || {};

(function () {
    function Buffer(viewPos, pageWidth, pageHeight, bufferSize)
    {
        this._pageWidth = pageWidth;
        this._pageHeight = pageHeight;
        this._bufferSize = bufferSize;
        this._numPages = bufferSize * bufferSize;

        this._firstPass = true;

        this.initialise(viewPos);

        console.log("Hello from Buffer constructor");
    }

    var p = Buffer.prototype;

    p.initialise = function(viewPos)
    {
        // makes the buffer into a grid graph of pages
        this.makeGridGraph();

        // identify all pages with a geo code
        this.fillGeoCodes(viewPos);

        // fill page data with random cells
        this.fillBufferTestData();

        console.log("Hello from Buffer::initialise");
    };

    p.updateDebugDisplay = function(pos, sprites, tileTextures)
    {
        var size = this._bufferSize;
        var page = this._buffer[0];

        for(var i = 0; i < size; i++)
        {
            for(var j = 0; j < size; j++)
            {
                var tex = tileTextures[0];

                if(page.stale)
                {
                    tex = tileTextures[1];
                }

                sprites[j + i * size].texture = tex;

                page = page.r;
            }
            page = page.d;
        }

        var geoCode = this.geoCode(pos);

        var f = this.findPage(geoCode);

        if(f.page)
        {
            sprites[f.x + f.y * size].texture = tileTextures[2];
        }
    };

    p.fastTileCode = function(pos, sprites, tileTextures)
    {
        var geoCode = this.geoCode(pos);

        if(this._firstPass)
        {
            this._geoCache = geoCode;
            this._firstPass = false;
        }

        var page = this.findPage(geoCode).page;
        var leftPage = page;

        if(page)
        {
            if(!_.isEqual(this._geoCache, geoCode))
            {
                var p = page.r.r.u.u;
                for(var k = 0; k < 5; k++)
                {
                    console.log("Stale");
                    var gc = p.l.geoCode;
                    console.log("Old gc=" + p.geoCode.x + " " + p.geoCode.y);
                    gc.x += this._pageWidth;
                    p.geoCode = gc;
                    console.log("New gc=" + p.geoCode.x + " " + p.geoCode.y);
                    p.stale = true;
                    p = p.d;
                }
                this._geoCache = geoCode;
            }

            var edge = { x: this._pageWidth, y: this._pageHeight };
            var offset = { x: pos.x - geoCode.x, y: pos.y - geoCode.y };

            var y = offset.y;

            for(var i = 0; i < edge.y; i++)
            {
                var x = offset.x;

                for(var j = 0; j < edge.x; j++)
                {
                    tileCode = page.data[x + y * this._pageWidth];
                    sprites[j + i * this._pageWidth].texture = tileTextures[tileCode];

                    x++;
                    if( x == edge.x )
                    {
                        x = 0;
                        page = page.r;
                    }
                }

                y++;
                if( y == edge.y )
                {
                    y = 0;
                    leftPage = leftPage.d;
                }

                page = leftPage;
            }
        }
    };

    p.findPage = function(geoCode)
    {
        var size = this._bufferSize;
        var page = this._buffer[0];

        for(var i = 0; i < size; i++)
        {
            for(var j = 0; j < size; j++)
            {
                if(_.isEqual(page.geoCode, geoCode))
                {
                    return {x: j, y: i, page: page};
                }
                page = page.r;
            }
            page = page.d;
        }

        return {x: -1, y: -1, page: null};
    };

    p.fillBufferTestData = function()
    {
        var size = this._bufferSize;
        var page = this._buffer[0];
        var cellValue = 0;

        for(var i = 0; i < size; i++)
        {
            for(var j = 0; j < size; j++)
            {
                this.fillPageTestData(page, cellValue);
                page = page.r;
                cellValue++;
            }
            page = page.d;
        }
    };

    p.fillPageTestData = function(page, cellValue)
    {
        for(var x = 0; x < this._pageWidth; x++)
        {
            for(var y = 0; y < this._pageHeight; y++)
            {
                page.data[x + y * this._pageWidth] = cellValue;
            }
        }
    };

    // Fill pages with geo codes
    p.fillGeoCodes = function(viewPos)
    {
        var tempPos = {x: viewPos.x - this._pageWidth*2, y: viewPos.y - this._pageHeight*2};
        var startx = tempPos.x;

        var size = this._bufferSize;
        var page = this._buffer[0];

        for(var i = 0; i < size; i++)
        {
            for(var j = 0; j < size; j++)
            {
                page.geoCode = this.geoCode(tempPos);

                console.log(page.geoCode);

                tempPos.x += this._pageWidth;
                page = page.r;
            }

            tempPos.x = startx;
            tempPos.y += this._pageHeight;
            page = page.d;
        }
    };

    p.geoCode = function(pos)
    {
        return {
            x: pos.x - ( pos.x % this._pageWidth ),
            y: pos.y - ( pos.y % this._pageHeight )
        };
    };

    // Create an undirected grid graph consisting of page nodes
    p.makeGridGraph = function()
    {
        var pagesQ = new Queue();
        this._buffer = [];

        for(var i = 0; i < this._numPages; i++)
        {
            var page = { id: 'page-'+i, data: [], stale: false, l: null, r: null, u: null, d: null };
            this._buffer.push(page);
            pagesQ.enqueue(page);
        }

        this.linkAdjacencyProperties(pagesQ);
    };

    // Link the left, right, up and down (l,r,u,d) adjacency list of each page
    p.linkAdjacencyProperties = function(pagesQ)
    {
        var rowQ = new Queue();
        var size = this._bufferSize;

        // push the first row
        for(var i = 0; i < size; i++)
        {
            var p = pagesQ.dequeue();
            rowQ.enqueue(p);
            // rotate the first row back on to the end of the pagesQ so
            // that the final row gets linked to the first row
            pagesQ.enqueue(p);
        }

        // iterate rows
        for(i = 0; i < size; i++)
        {
            var nextRowQ = new Queue();

            // add the first page in the row to the end
            // this ensures that the final page in the row gets linked to the first
            rowQ.enqueue(rowQ.peek());

            // iterate columns
            for(var j = 0; j < size; j++)
            {
                var page = rowQ.dequeue();
                var nextRowPage = pagesQ.dequeue();

                page.r = rowQ.peek();
                page.r.l = page;
                page.d = nextRowPage;
                page.d.u = page;

                nextRowQ.enqueue(nextRowPage);
            }

            rowQ = nextRowQ;
        }
    };

    ORE.Buffer = Buffer;

}());

/*
* ORE - Online Roguelike Engine
*
* Copyright (C) 2016  Mark Purser
* Released under the MIT license
* http://github.com/markpurser/ORE/LICENSE
*
* Tile rendering based on
* https://github.com/jice-nospam/yendor.ts
* Copyright (c) 2014 Jice
*/

/**
* @module ORE
*/

this.ORE = this.ORE || {};

(function () {
    ORE.init = function (oreOptions)
    {
        this._renderingCanvas = oreOptions.renderCanvas;
        this._debugCanvas = oreOptions.debugCanvas;

        this._keyboard = new Keyboard();

        var tileWidthPx = oreOptions.tileWidthPx;
        var tileHeightPx = oreOptions.tileHeightPx;

        var spriteGridWidth = oreOptions.viewWidth;
        var spriteGridHeight = oreOptions.viewHeight;

        var bufferSize = 6;
        var viewPos = { x:2060, y:2070 };
        this._buffer = new ORE.Buffer(viewPos, spriteGridWidth, spriteGridHeight, bufferSize);

        var loader = PIXI.loader;
        loader.add('tilesheet', oreOptions.tilesheetImage);
        loader.load( function( loader, resources )
        {
            var stats = {
                fpsText: new PIXI.Text('', {font: '24px Arial', fill: 0xff1010}),
                fpsTimer: 0,
                currentFrameCount: 0
            };

            var numTilesX = resources.tilesheet.texture.width / tileWidthPx;
            var numTilesY = resources.tilesheet.texture.height / tileHeightPx;

            var bufferWidth = spriteGridWidth * bufferSize;
            var bufferHeight = spriteGridHeight * bufferSize;

            // init tile textures
            var tileTextures = [];
            _.range(numTilesX).forEach(function(x)
            {
                _.range(numTilesY).forEach(function(y)
                {
                    var rect = new PIXI.Rectangle(x * tileWidthPx, y * tileHeightPx, tileWidthPx, tileHeightPx);
                    tileTextures[x + y * numTilesX] = new PIXI.Texture(resources.tilesheet.texture, rect);
                });
            });

            // create a new instance of a pixi container
            var parentContainer = new PIXI.Container();

            var worldSprites = [];    
            var worldSpriteContainer = ORE.SpriteGrid(
                spriteGridWidth, spriteGridHeight, tileWidthPx, tileHeightPx, tileTextures[0], worldSprites);

            var debugSprites = [];    
            var debugSpriteContainer = ORE.SpriteGrid(
                bufferSize, bufferSize, tileWidthPx, tileHeightPx, tileTextures[0], debugSprites);


            parentContainer.addChild(worldSpriteContainer);
            parentContainer.addChild(stats.fpsText);

            var playerX = viewPos.x * tileWidthPx;
            var playerY = viewPos.y * tileHeightPx;

            // create a renderer instance
            var pixiOptions = {
                clearBeforeRender: true,
                preserveDrawingBuffer: false,
                resolution: 1,
                view: ORE._renderingCanvas
            };

            ORE._renderer = PIXI.autoDetectRenderer(
                oreOptions.renderCanvasSize.width, oreOptions.renderCanvasSize.height, pixiOptions);
            ORE._renderer.backgroundColor = 0x66ff99;

            // create a renderer instance
            var pixiDebugOptions = {
                clearBeforeRender: true,
                preserveDrawingBuffer: false,
                resolution: 2,
                view: ORE._debugCanvas
            };

            ORE._debugRenderer = PIXI.autoDetectRenderer(
                oreOptions.debugCanvasSize.width, oreOptions.debugCanvasSize.height, pixiDebugOptions);
            ORE._debugRenderer.backgroundColor = 0xaa4444;

            // add the renderer view element to the DOM
            //document.body.appendChild(ORE._renderer.view);


            requestAnimationFrame(animate);

            function animate()
            {
                if(oreOptions.displayStats)
                {
                    ORE.updateStats(stats);
                }

                if(ORE._keyboard.isKeyPressed(Keyboard.KEYS.UP))
                {
                    playerY--;
                }

                if(ORE._keyboard.isKeyPressed(Keyboard.KEYS.DOWN))
                {
                    playerY++;
                }

                if(ORE._keyboard.isKeyPressed(Keyboard.KEYS.LEFT))
                {
                    playerX--;
                }

                if(ORE._keyboard.isKeyPressed(Keyboard.KEYS.RIGHT))
                {
                    playerX++;
                }

                viewPos.x = playerX >> 4;
                viewPos.y = playerY >> 4;
                var scrollX = playerX & 15;
                var scrollY = playerY & 15;
                worldSpriteContainer.position.x = -scrollX;
                worldSpriteContainer.position.y = -scrollY;

                ORE._buffer.fastTileCode(viewPos, worldSprites, tileTextures);

                ORE._buffer.updateDebugDisplay(viewPos, debugSprites, tileTextures);

                requestAnimationFrame(animate);

                // render
                ORE._renderer.render(parentContainer);
                ORE._debugRenderer.render(debugSpriteContainer);
            }
        });
    };

    ORE.updateStats = function (stats)
    {
        stats.currentFrameCount++;
        if( stats.fpsTimer === 0 )
        {
            stats.fpsTimer = new Date().getTime();
        }
        else if( new Date().getTime() - stats.fpsTimer > 1000 )
        {
            var rendererTypeStr = 'Canvas';
            if(ORE._renderer instanceof PIXI.WebGLRenderer)
            {
                rendererTypeStr = 'WebGL';
            }
            stats.fpsText.text = 'fps: ' + stats.currentFrameCount + '\npixi: ' + PIXI.VERSION + '\nRenderer: ' + rendererTypeStr;
            stats.fpsTimer = new Date().getTime();
            stats.currentFrameCount = 0;
        }
    };

})();

/*
* ORE - Online Roguelike Engine
*
* Copyright (C) 2016  Mark Purser
* Released under the MIT license
* http://github.com/markpurser/ORE/LICENSE
*/

/**
* @module SpriteGrid
*
* Facade for creation of grid of PIXI Sprites in a PIXI container
*/

this.ORE = this.ORE || {};

(function () {
    function SpriteGrid(gridWidth, gridHeight, tileWidthPx, tileHeightPx, tileTexture, sprites)
    {
        spriteContainer = new PIXI.Container();

        // init grid
        _.range(gridWidth).forEach(function(x)
        {
            _.range(gridHeight).forEach(function(y)
            {
                var sprite = new PIXI.Sprite(tileTexture);
                sprite.position.x = x * tileWidthPx;
                sprite.position.y = y * tileHeightPx;
                sprite.width = tileWidthPx;
                sprite.height = tileHeightPx;
                sprites[x + y * gridWidth] = sprite;
                spriteContainer.addChild(sprite);
            });
        });

        return spriteContainer;
    }


    ORE.SpriteGrid = SpriteGrid;

}());
